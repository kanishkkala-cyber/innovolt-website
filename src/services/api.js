import { supabaseHelpers, supabase, TABLES } from '../config/supabase';

const apiService = {
  // Submit contact form (creates a lead without vehicle reference)
  submitContact: async (formData) => {
    try {
      // Format phone number (add +91 if not present)
      let phoneNumber = formData.phone.trim();
      if (!phoneNumber.startsWith('+91') && !phoneNumber.startsWith('91')) {
        phoneNumber = `+91${phoneNumber}`;
      } else if (phoneNumber.startsWith('91') && !phoneNumber.startsWith('+91')) {
        phoneNumber = `+${phoneNumber}`;
      }

      const leadData = {
        name: formData.name.trim(),
        phone_number: phoneNumber,
        city: formData.city.trim(),
        vehicle_id: null, // No vehicle reference for contact form
        lead_type: 'contact_form'
        // created_at will be auto-generated by Supabase
      };

      const result = await supabaseHelpers.createLead(leadData);
      
      return {
        success: true,
        message: 'Contact form submitted successfully!',
        data: result
      };
    } catch (error) {
      throw new Error(error.message || 'Failed to submit contact form');
    }
  },

  // Submit callback request (creates a lead without vehicle reference)
  submitCallback: async (formData) => {
    try {
      // Format phone number (add +91 if not present)
      let phoneNumber = formData.phone.trim();
      if (!phoneNumber.startsWith('+91') && !phoneNumber.startsWith('91')) {
        phoneNumber = `+91${phoneNumber}`;
      } else if (phoneNumber.startsWith('91') && !phoneNumber.startsWith('+91')) {
        phoneNumber = `+${phoneNumber}`;
      }

      const leadData = {
        name: formData.name.trim(),
        phone_number: phoneNumber,
        city: formData.city.trim(),
        vehicle_id: null, // No vehicle reference for callback
        lead_type: 'callback_request'
        // created_at will be auto-generated by Supabase
      };

      const result = await supabaseHelpers.createLead(leadData);
      
      return {
        success: true,
        message: 'Callback request submitted successfully!',
        data: result
      };
    } catch (error) {
      throw new Error(error.message || 'Failed to submit callback request');
    }
  },

  // Submit lead capture (creates a lead with vehicle reference)
  submitLead: async (leadData) => {
    try {
      // Format phone number (add +91 if not present)
      let phoneNumber = leadData.phone.trim();
      if (!phoneNumber.startsWith('+91') && !phoneNumber.startsWith('91')) {
        phoneNumber = `+91${phoneNumber}`;
      } else if (phoneNumber.startsWith('91') && !phoneNumber.startsWith('+91')) {
        phoneNumber = `+${phoneNumber}`;
      }

      // vehicleId should be the UUID from the Vehicles table
      const vehicleId = leadData.vehicleId || null;

      const leadPayload = {
        name: leadData.name.trim(),
        phone_number: phoneNumber,
        city: leadData.city.trim(),
        vehicle_id: vehicleId, // UUID reference to Vehicles table id
        lead_type: 'vehicle_inquiry'
        // created_at will be auto-generated by Supabase
      };

      const result = await supabaseHelpers.createLead(leadPayload);
      
      return {
        success: true,
        message: 'Lead submitted successfully!',
        data: result
      };
    } catch (error) {
      throw new Error(error.message || 'Failed to submit lead');
    }
  },

  // Get cars/vehicles from Supabase
  getCars: async (filters = {}) => {
    try {
      const vehicles = await supabaseHelpers.getVehicles(filters);
      
      // If no vehicles from Supabase, return empty array
      if (!vehicles || vehicles.length === 0) {
        return [];
      }
      
      let missingDataCount = 0;
      let transformedCount = 0;
      
      // Transform Supabase data to match frontend expectations
      const transformedVehicles = vehicles
        .filter(vehicle => {
          // Only filter out vehicles with no ID (required for routing)
          if (!vehicle || !vehicle.id) {
            missingDataCount++;
            return false;
          }
          return true;
        })
        .map((vehicle, index) => {
          try {
        // Track vehicles with missing critical fields (still process but track)
        if (!vehicle.OEM || !vehicle.Model) {
          missingDataCount++;
        }
        
        // Format price in Indian numbering system with commas
        const formatIndianPrice = (priceStr) => {
          if (!priceStr) return '';
          // Remove any existing formatting
          const numericPrice = parseInt(priceStr.replace(/[â‚¹,\s]/g, '')) || 0;
          
          // Convert to string and add commas in Indian style (last 3 digits, then every 2)
          const priceString = numericPrice.toString();
          if (priceString.length <= 3) {
            return `â‚¹${priceString}`;
          }
          
          let result = priceString.slice(-3); // Last 3 digits
          for (let i = priceString.length - 3; i > 0; i -= 2) {
            result = priceString.slice(Math.max(0, i - 2), i) + ',' + result;
          }
          
          return `â‚¹${result}`;
        };
        
         // Helper function to convert bytea (hex) to base64 data URL or decode URL
         const byteaToDataUrl = (byteaData) => {
           if (!byteaData) return null;
           
           try {
             if (typeof byteaData === 'string' && byteaData.startsWith('data:')) {
               return byteaData;
             }
             
             let hexString = null;
             if (typeof byteaData === 'string') {
               hexString = byteaData.replace(/^\\x/, '').replace(/^\\\\x/, '');
               
               // Check if it's hex-encoded ASCII (URL)
               if (hexString.length > 10) {
                 const possibleUrl = String.fromCharCode(...hexString.match(/.{1,2}/g).slice(0, 20).map(b => parseInt(b, 16)));
                 if (possibleUrl.startsWith('http://') || possibleUrl.startsWith('https://')) {
                   const decodedUrl = String.fromCharCode(...hexString.match(/.{1,2}/g).map(b => parseInt(b, 16)));
                   return getImageUrl(decodedUrl);
                 }
               }
               
               // It's actual image data - convert hex to base64
               if (hexString && hexString.length > 0) {
                 const bytes = new Uint8Array(hexString.match(/.{1,2}/g).map(b => parseInt(b, 16)));
                 const binaryString = Array.from(bytes, byte => String.fromCharCode(byte)).join('');
                 const base64 = btoa(binaryString);
                 
                 let mimeType = 'image/jpeg';
                 const firstBytes = Array.from(bytes.slice(0, 4));
                 if (firstBytes[0] === 0xFF && firstBytes[1] === 0xD8) mimeType = 'image/jpeg';
                 else if (firstBytes[0] === 0x89 && firstBytes[1] === 0x50) mimeType = 'image/png';
                 else if (firstBytes[0] === 0x47 && firstBytes[1] === 0x49) mimeType = 'image/gif';
                 else if (firstBytes[0] === 0x52 && firstBytes[1] === 0x49) mimeType = 'image/webp';
                 
                 return `data:${mimeType};base64,${base64}`;
               }
             }
             
             // If it's base64 string already
             if (typeof byteaData === 'string' && !byteaData.startsWith('\\x') && /^[A-Za-z0-9+/=]+$/.test(byteaData)) {
               return `data:image/jpeg;base64,${byteaData}`;
             }
             
             return null;
           } catch (error) {
             console.error('Error converting bytea:', error);
             return null;
           }
         };
         
         // Helper function to get image URL - handles Supabase Storage, external URLs, and Google Drive
         const getImageUrl = (url) => {
           if (!url) return null;
           
           // If it's already a full URL (http/https), return as is
           if (url.startsWith('http://') || url.startsWith('https://')) {
             // Check if it's already a Supabase Storage URL (no conversion needed)
             if (url.includes('supabase.co/storage/v1/object/public/')) {
               return url; // Already a full Supabase Storage URL, use directly
             }
             
             // Handle Google Drive URLs (for backward compatibility)
             if (url.includes('drive.google.com')) {
               let fileId = null;
               if (url.includes('uc?export=view&id=')) {
                 fileId = url.split('uc?export=view&id=')[1].split('&')[0];
               } else if (url.includes('file/d/')) {
                 fileId = url.split('file/d/')[1].split('/')[0];
               } else if (url.includes('id=')) {
                 fileId = url.split('id=')[1].split('&')[0];
               }
               if (fileId) {
                 return `https://drive.google.com/uc?export=view&id=${fileId}`;
               }
             }
             
             // Other external URLs (CDN, etc.) - return as-is
             return url;
           }
           
           // If it's a file path (doesn't start with http), convert to Supabase Storage public URL
           if (url && url.trim() !== '') {
             // Check if it's already a Supabase Storage URL
             if (url.includes('supabase.co/storage/v1/object/public/')) {
               return url;
             }
             
             // It's a file path - convert to full URL
             const supabaseUrl = import.meta.env.VITE_SUPABASE_URL;
             if (supabaseUrl) {
               const bucketName = 'Vehicle-images'; // Match your bucket name exactly
               return `${supabaseUrl.replace(/\/$/, '')}/storage/v1/object/public/${bucketName}/${url.trim()}`;
             }
           }
           
           return url;
         };
         
         // Collect all images - handle bytea (hex), base64, and URLs
         const imageUrls = [
           vehicle.image_url_1,
           vehicle.image_url_2,
           vehicle.image_url_3,
           vehicle.image_url_4
         ]
           .filter(data => data)
           .map(data => {
             // Check if bytea (hex) or base64
             if (typeof data === 'string' && (data.startsWith('\\x') || /^[0-9a-fA-F]+$/.test(data.replace(/\\x/g, '')))) {
               return byteaToDataUrl(data);
             }
             // Base64 string (no \x prefix)
             if (typeof data === 'string' && /^[A-Za-z0-9+/=]+$/.test(data) && data.length > 50) {
               return `data:image/jpeg;base64,${data}`;
             }
             // Regular URL (text) - handle Supabase Storage URLs and file paths
             if (typeof data === 'string' && data.trim() !== '') {
               const processedUrl = getImageUrl(data.trim());
               // Log for the specific vehicle being tested
               if (vehicle.id === '5117e01c-9133-4f07-a9bb-e72dbbac03b2') {
                 console.log('ðŸ–¼ï¸ [CARD] Vehicle card image processing:', {
                   vehicleId: vehicle.id,
                   originalData: data.substring(0, 100), // First 100 chars
                   processedUrl: processedUrl?.substring(0, 100)
                 });
               }
               return processedUrl;
             }
             return null;
           })
           .filter(url => url !== null);
         
         // Use first image as main image, or placeholder if none
         const mainImage = imageUrls.length > 0 ? imageUrls[0] : '/placeholder-vehicle.svg';
         
         // Log for testing
         if (vehicle.id === '5117e01c-9133-4f07-a9bb-e72dbbac03b2') {
           console.log('âœ… [CARD] Final image URL for vehicle card:', {
             vehicleId: vehicle.id,
             mainImage: mainImage,
             totalImages: imageUrls.length,
             imageUrls: imageUrls
           });
         }
         
        // Safely get registration year
        let registrationYear = 'N/A';
        try {
          if (vehicle['Registration date']) {
            const regDate = new Date(vehicle['Registration date']);
            if (!isNaN(regDate.getTime())) {
              registrationYear = regDate.getFullYear().toString();
            }
          }
        } catch (e) {
          // If date parsing fails, use fallback
          registrationYear = 'N/A';
        }
        
        // Safely get kilometers
        let kilometers = 'N/A km';
        try {
          if (vehicle['Kms run'] !== null && vehicle['Kms run'] !== undefined) {
            kilometers = `${(vehicle['Kms run'] / 1000).toFixed(1)}k km`;
          }
        } catch (e) {
          kilometers = 'N/A km';
        }
        
        const transformed = {
          id: vehicle.id, // Use UUID as ID
          title: `${registrationYear} ${vehicle.OEM || 'Unknown'} ${vehicle.Model || 'Vehicle'}`,
          image: mainImage, // Use first available image or placeholder
          kilometers: kilometers,
          price: formatIndianPrice(vehicle['Selling Price']),
          emi: vehicle.EMI || 'N/A',
          location: `${vehicle.City || 'N/A'}, ${vehicle.State || 'N/A'}`, // Show city and state
          brand: vehicle.OEM || 'Unknown',
          year: registrationYear,
          registrationYear: registrationYear,
          images: imageUrls.length > 0 ? imageUrls : ['/placeholder-vehicle.svg'], // Use actual images or placeholder
          // Additional Supabase fields - using exact column names from schema
          model: vehicle.Model,
          modelType: vehicle['Model Type'],
          mainStage: vehicle['Main Stage'],
          state: vehicle.State,
          registrationDate: vehicle['Registration date'],
          seizedDate: vehicle['Seized date'],
          inventoryDays: vehicle['Inventory days'],
          loadCapacity: vehicle['Load Capacity (kg)'],
          batteryCapacity: vehicle['Battery Capacity (kwt)'],
          chargingTime: vehicle['Charging time (hours)'],
          topSpeed: vehicle['Top Speed (km/h)']
        };
        
            return transformed;
          } catch (error) {
            // Log error but don't crash - return null to filter it out
            console.error(`âŒ [VEHICLES] Error transforming vehicle ${vehicle?.id || 'unknown'}:`, error);
            missingDataCount++;
            return null;
          }
        })
        .filter(vehicle => vehicle !== null); // Remove any null entries from errors

      // Log summary for debugging
      console.log(`ðŸ“Š [VEHICLES] Total fetched: ${vehicles.length}, Transformed: ${transformedVehicles.length}, Missing/Filtered: ${missingDataCount}`);
      
      if (missingDataCount > 0) {
        console.warn(`âš ï¸ [VEHICLES] ${missingDataCount} vehicles were filtered out due to missing data or errors`);
      }
      
      return transformedVehicles;
    } catch (error) {
      // Return sample data as fallback
      return [
        {
          id: 'SAMPLE001',
          title: '2022 Piaggio Ape E-City',
          image: '/placeholder-vehicle.svg',
          kilometers: '28.5k km',
          price: 'â‚¹2.45 lakh',
          emi: 'â‚¹8,900/m*',
          location: 'Mumbai, Maharashtra',
          brand: 'Piaggio',
          year: '2022',
          registrationYear: '2022',
          vehicleNumber: 'SAMPLE001',
          modelType: 'E-City',
          loadCapacity: '300 kg',
          batteryCapacity: '3.5 kwt',
          chargingTime: '6 hours',
          topSpeed: '45 km/h',
          images: ['/placeholder-vehicle.svg']
        }
      ];
    }
  },

  // Get single vehicle by UUID
  getCar: async (id) => {
    try {
      const vehicle = await supabaseHelpers.getVehicleById(id);
      
      if (!vehicle) {
        return null;
      }

      // Format price in Indian numbering system with commas
      const formatIndianPrice = (priceStr) => {
        if (!priceStr) return '';
        const numericPrice = parseInt(priceStr.replace(/[â‚¹,\s]/g, '')) || 0;
        
        // Convert to string and add commas in Indian style (last 3 digits, then every 2)
        const priceString = numericPrice.toString();
        if (priceString.length <= 3) {
          return `â‚¹${priceString}`;
        }
        
        let result = priceString.slice(-3); // Last 3 digits
        for (let i = priceString.length - 3; i > 0; i -= 2) {
          result = priceString.slice(Math.max(0, i - 2), i) + ',' + result;
        }
        
        return `â‚¹${result}`;
      };

      // Helper function to convert bytea (hex) data to base64 data URL
      const byteaToDataUrl = (byteaData) => {
        if (!byteaData) return null;
        
        try {
          // If it's already a data URL, return as is
          if (typeof byteaData === 'string' && byteaData.startsWith('data:')) {
            return byteaData;
          }
          
          // Handle hex-encoded bytea (starts with \x)
          let hexString = null;
          if (typeof byteaData === 'string') {
            // Remove \x prefix if present and handle escaped versions
            hexString = byteaData.replace(/^\\x/, '').replace(/^\\\\x/, '').replace(/\\\\x/g, '');
            
            // Check if it's hex-encoded ASCII (URL) - decode first 50 chars to check
            if (hexString.length > 10) {
              try {
                const sample = hexString.substring(0, Math.min(100, hexString.length));
                const possibleUrl = String.fromCharCode(...sample.match(/.{1,2}/g).map(b => parseInt(b, 16)));
                
                if (possibleUrl.startsWith('http://') || possibleUrl.startsWith('https://')) {
                  // It's a hex-encoded URL, decode the entire thing
                  const decodedUrl = String.fromCharCode(...hexString.match(/.{1,2}/g).map(b => parseInt(b, 16)));
                  console.log('ðŸ” [IMAGE] Detected hex-encoded URL, decoded to:', decodedUrl);
                  return getImageUrl(decodedUrl);
                }
              } catch (e) {
                // Not a URL, continue to image processing
              }
            }
          }
          
          // It's actual image data - convert hex to base64
          if (hexString && hexString.length > 0) {
            // Convert hex string to bytes, then to base64
            const bytes = new Uint8Array(hexString.match(/.{1,2}/g).map(b => parseInt(b, 16)));
            const binaryString = Array.from(bytes, byte => String.fromCharCode(byte)).join('');
            const base64 = btoa(binaryString);
            
            // Detect MIME type from first bytes
            let mimeType = 'image/jpeg'; // Default
            const firstBytes = Array.from(bytes.slice(0, 4));
            
            // JPEG: FF D8 FF
            if (firstBytes[0] === 0xFF && firstBytes[1] === 0xD8 && firstBytes[2] === 0xFF) {
              mimeType = 'image/jpeg';
            }
            // PNG: 89 50 4E 47
            else if (firstBytes[0] === 0x89 && firstBytes[1] === 0x50 && firstBytes[2] === 0x4E && firstBytes[3] === 0x47) {
              mimeType = 'image/png';
            }
            // GIF: 47 49 46 38
            else if (firstBytes[0] === 0x47 && firstBytes[1] === 0x49 && firstBytes[2] === 0x46 && firstBytes[3] === 0x38) {
              mimeType = 'image/gif';
            }
            // WEBP: 52 49 46 46
            else if (firstBytes[0] === 0x52 && firstBytes[1] === 0x49 && firstBytes[2] === 0x46 && firstBytes[3] === 0x46) {
              mimeType = 'image/webp';
            }
            
            return `data:${mimeType};base64,${base64}`;
          }
          
          // If it's already base64 string (from Supabase)
          if (typeof byteaData === 'string' && !byteaData.startsWith('\\x')) {
            // Check if it looks like base64
            if (/^[A-Za-z0-9+/=]+$/.test(byteaData)) {
              return `data:image/jpeg;base64,${byteaData}`;
            }
          }
          
          return null;
        } catch (error) {
          console.error('Error converting bytea to data URL:', error);
          return null;
        }
      };
      
      // Helper function to get image URL - handles Supabase Storage, external URLs, and Google Drive
      const getImageUrl = (url) => {
        if (!url) return null;
        
        // If it's already a full URL (http/https), return as is
        if (url.startsWith('http://') || url.startsWith('https://')) {
          // Handle Google Drive URLs
          if (url.includes('drive.google.com')) {
            // Extract file ID and use direct view format
            let fileId = null;
            if (url.includes('uc?export=view&id=')) {
              fileId = url.split('uc?export=view&id=')[1].split('&')[0];
            } else if (url.includes('file/d/')) {
              fileId = url.split('file/d/')[1].split('/')[0];
            } else if (url.includes('id=')) {
              fileId = url.split('id=')[1].split('&')[0];
            }
            
            if (fileId) {
              return `https://drive.google.com/uc?export=view&id=${fileId}`;
            }
          }
          return url; // Return other external URLs as-is
        }
        
        // If it's a Supabase Storage path (doesn't start with http), convert to public URL
        // Support both full URLs and file paths
        if (url && url.trim() !== '') {
          // Check if it's already a Supabase Storage URL
          if (url.includes('supabase.co/storage/v1/object/public/')) {
            return url; // Already full URL, return as-is
          }
          
          // It's a file path - convert to full Supabase Storage URL
          const supabaseUrl = import.meta.env.VITE_SUPABASE_URL;
          if (supabaseUrl) {
            const baseUrl = supabaseUrl.replace(/\/$/, '');
            const bucketName = 'Vehicle-images'; // Match your bucket name exactly
            return `${baseUrl}/storage/v1/object/public/${bucketName}/${url.trim()}`;
          }
        }
        
        return url;
      };
      
      // Collect all image URLs - handle both text URLs and bytea data
      const imageUrls = [
        vehicle.image_url_1,
        vehicle.image_url_2,
        vehicle.image_url_3,
        vehicle.image_url_4
      ]
        .filter(data => data) // Filter out null/undefined
        .map(data => {
          // Check if it's bytea (hex) data (starts with \x or is hex string)
          if (typeof data === 'string' && (data.startsWith('\\x') || /^[0-9a-fA-F]+$/.test(data.replace(/\\x/g, '')))) {
            return byteaToDataUrl(data);
          }
          // Regular URL string
          if (typeof data === 'string' && data.trim() !== '') {
            return getImageUrl(data.trim());
          }
          return null;
        })
        .filter(url => url !== null); // Remove failed conversions
      
      // Use first image as main image, or placeholder if none
      const mainImage = imageUrls.length > 0 ? imageUrls[0] : '/placeholder-vehicle.svg';
      
      // Transform to match frontend expectations
      const transformed = {
        id: vehicle.id, // Use UUID as ID
        title: `${new Date(vehicle['Registration date']).getFullYear()} ${vehicle.OEM} ${vehicle.Model}`,
        image: mainImage, // Use first available image or placeholder
        kilometers: `${(vehicle['Kms run'] / 1000).toFixed(1)}k km`,
        price: formatIndianPrice(vehicle['Selling Price']),
        emi: vehicle.EMI,
        location: `${vehicle.City}, ${vehicle.State}`, // Show city and state
        brand: vehicle.OEM,
        year: new Date(vehicle['Registration date']).getFullYear().toString(),
        registrationYear: new Date(vehicle['Registration date']).getFullYear().toString(),
        images: imageUrls.length > 0 ? imageUrls : ['/placeholder-vehicle.svg'], // Use actual images or placeholder
        // Additional Supabase fields - using exact column names from schema
        model: vehicle.Model,
        modelType: vehicle['Model Type'],
        mainStage: vehicle['Main Stage'],
        state: vehicle.State,
        registrationDate: vehicle['Registration date'],
        seizedDate: vehicle['Seized date'],
        inventoryDays: vehicle['Inventory days'],
        loadCapacity: vehicle['Load Capacity (kg)'],
        batteryCapacity: vehicle['Battery Capacity (kwt)'],
        chargingTime: vehicle['Charging time (hours)'],
          topSpeed: vehicle['Top Speed (km/h)']
        };
      
      return transformed;
    } catch (error) {
      return null;
    }
  },

  // Health check (for compatibility)
  healthCheck: async () => {
    try {
      await supabaseHelpers.getVehicles({ limit: 1 });
      return { status: 'OK', message: 'Supabase connection successful' };
    } catch (error) {
      throw new Error('Supabase connection failed');
    }
  },

  // Get comparison data for multiple vehicles
  async getComparisonData(vehicleIds) {
    try {
      // Exclude Registration_No from select for privacy/compliance
      const { data, error } = await supabase
        .from(TABLES.VEHICLES)
        .select('id, OEM, Model, "Model Type", "Main Stage", City, State, "Registration date", "Seized date", "Inventory days", "Kms run", "Selling Price", EMI, "Load Capacity (kg)", "Battery Capacity (kwt)", "Charging time (hours)", "Top Speed (km/h)", image_url_1, image_url_2, image_url_3, image_url_4')
        .in('id', vehicleIds);
      
      if (error) {
        throw error;
      }

      // Format price in Indian numbering system with commas
      const formatIndianPrice = (priceStr) => {
        if (!priceStr) return '';
        const numericPrice = parseInt(priceStr.replace(/[â‚¹,\s]/g, '')) || 0;
        
        // Convert to string and add commas in Indian style (last 3 digits, then every 2)
        const priceString = numericPrice.toString();
        if (priceString.length <= 3) {
          return `â‚¹${priceString}`;
        }
        
        let result = priceString.slice(-3); // Last 3 digits
        for (let i = priceString.length - 3; i > 0; i -= 2) {
          result = priceString.slice(Math.max(0, i - 2), i) + ',' + result;
        }
        
        return `â‚¹${result}`;
      };

      // Transform the data for comparison
      const comparisonData = data.map(vehicle => {
        // Helper function to convert bytea (hex) to base64 data URL or decode URL
        const byteaToDataUrl = (byteaData) => {
          if (!byteaData) return null;
          try {
            if (typeof byteaData === 'string' && byteaData.startsWith('data:')) return byteaData;
            let hexString = null;
            if (typeof byteaData === 'string') {
              hexString = byteaData.replace(/^\\x/, '').replace(/^\\\\x/, '');
              if (hexString.length > 10) {
                const possibleUrl = String.fromCharCode(...hexString.match(/.{1,2}/g).slice(0, 20).map(b => parseInt(b, 16)));
                if (possibleUrl.startsWith('http://') || possibleUrl.startsWith('https://')) {
                  const decodedUrl = String.fromCharCode(...hexString.match(/.{1,2}/g).map(b => parseInt(b, 16)));
                  return getImageUrl(decodedUrl);
                }
              }
              if (hexString && hexString.length > 0) {
                const bytes = new Uint8Array(hexString.match(/.{1,2}/g).map(b => parseInt(b, 16)));
                const binaryString = Array.from(bytes, byte => String.fromCharCode(byte)).join('');
                const base64 = btoa(binaryString);
                let mimeType = 'image/jpeg';
                const firstBytes = Array.from(bytes.slice(0, 4));
                if (firstBytes[0] === 0xFF && firstBytes[1] === 0xD8) mimeType = 'image/jpeg';
                else if (firstBytes[0] === 0x89 && firstBytes[1] === 0x50) mimeType = 'image/png';
                else if (firstBytes[0] === 0x47 && firstBytes[1] === 0x49) mimeType = 'image/gif';
                else if (firstBytes[0] === 0x52 && firstBytes[1] === 0x49) mimeType = 'image/webp';
                return `data:${mimeType};base64,${base64}`;
              }
            }
            if (typeof byteaData === 'string' && !byteaData.startsWith('\\x') && /^[A-Za-z0-9+/=]+$/.test(byteaData)) {
              return `data:image/jpeg;base64,${byteaData}`;
            }
            return null;
          } catch (error) {
            console.error('Error converting bytea:', error);
            return null;
          }
        };
        
        // Helper function to get image URL - handles Supabase Storage, external URLs, and Google Drive
        const getImageUrl = (url) => {
          if (!url) return null;
          if (url.startsWith('http://') || url.startsWith('https://')) {
            if (url.includes('drive.google.com')) {
              let fileId = null;
              if (url.includes('uc?export=view&id=')) {
                fileId = url.split('uc?export=view&id=')[1].split('&')[0];
              } else if (url.includes('file/d/')) {
                fileId = url.split('file/d/')[1].split('/')[0];
              } else if (url.includes('id=')) {
                fileId = url.split('id=')[1].split('&')[0];
              }
              if (fileId) {
                return `https://drive.google.com/uc?export=view&id=${fileId}`;
              }
            }
            return url;
          }
          if (url && url.trim() !== '') {
            // Check if already a full Supabase Storage URL
            if (url.includes('supabase.co/storage/v1/object/public/')) {
              return url;
            }
            // It's a file path - convert to full URL
            const supabaseUrl = import.meta.env.VITE_SUPABASE_URL;
            if (supabaseUrl) {
              const bucketName = 'Vehicle-images'; // Match your bucket name
              return `${supabaseUrl.replace(/\/$/, '')}/storage/v1/object/public/${bucketName}/${url.trim()}`;
            }
          }
          return url;
        };
        
        // Collect all images - handle bytea (hex), base64, and URLs
        const imageUrls = [
          vehicle.image_url_1,
          vehicle.image_url_2,
          vehicle.image_url_3,
          vehicle.image_url_4
        ]
          .filter(data => data)
          .map(data => {
            // Check if bytea (hex) or base64
            if (typeof data === 'string' && (data.startsWith('\\x') || /^[0-9a-fA-F]+$/.test(data.replace(/\\x/g, '')))) {
              return byteaToDataUrl(data);
            }
            // Base64 string (no \x prefix)
            if (typeof data === 'string' && /^[A-Za-z0-9+/=]+$/.test(data) && data.length > 50) {
              return `data:image/jpeg;base64,${data}`;
            }
            // Regular URL
            if (typeof data === 'string' && data.trim() !== '') {
              return getImageUrl(data.trim());
            }
            return null;
          })
          .filter(url => url !== null);
        
        // Use first image as main image, or placeholder if none
        const mainImage = imageUrls.length > 0 ? imageUrls[0] : '/placeholder-vehicle.svg';
        
        return {
          id: vehicle.id, // Use UUID
          title: `${new Date(vehicle['Registration date']).getFullYear()} ${vehicle.OEM} ${vehicle.Model}`,
          image: mainImage,
          price: formatIndianPrice(vehicle['Selling Price']),
          emi: vehicle.EMI,
          kilometers: `${(vehicle['Kms run'] / 1000).toFixed(1)}k km`,
          location: `${vehicle.City}, ${vehicle.State}`,
          brand: vehicle.OEM,
          year: new Date(vehicle['Registration date']).getFullYear().toString(),
          registrationYear: new Date(vehicle['Registration date']).getFullYear().toString(),
          // Additional comparison fields
          batteryCapacity: vehicle['Battery Capacity (kwt)'] || 'N/A',
          chargingTime: vehicle['Charging time (hours)'] || 'N/A',
          topspeed: vehicle['Top Speed (km/h)'] || 'N/A',
          loadCapacity: vehicle['Load Capacity (kg)'] || 'N/A',
          owners: vehicle['No. of Owners'] || 'N/A'
        };
      });

      return {
        success: true,
        data: comparisonData,
        count: comparisonData.length
      };
    } catch (error) {
      throw new Error('Failed to fetch comparison data');
    }
  }
};

export default apiService;